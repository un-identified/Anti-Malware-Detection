#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <math.h>

// Function to calculate the entropy of a buffer.
double calculate_entropy(const unsigned char *data, size_t size) {
    int freq[256] = {0};

    for (size_t i = 0; i < size; i++) {
        freq[data[i]]++;
    }

    double entropy = 0.0;
    for (int i = 0; i < 256; i++) {
        if (freq[i] > 0) {
            double probability = (double)freq[i] / size;
            entropy -= probability * log2(probability);
        }
    }

    return entropy;
}

int main() {
    // Create a CSV file to store the process data.
    FILE *fp = fopen("process_data.csv", "w");
    if (fp == NULL) {
        perror("fopen");
        exit(1);
    }

    // Open the directory /proc to read the list of processes.
    DIR *proc_dir = opendir("/proc");
    if (proc_dir == NULL) {
        perror("opendir");
        exit(1);
    }

    struct dirent *entry;

    // Iterate over all running processes and collect the process data.
    while ((entry = readdir(proc_dir)) != NULL) {
        // Check if the entry is a directory and represents a process ID.
        if (entry->d_type == DT_DIR) {
            char proc_path[PATH_MAX];
            snprintf(proc_path, PATH_MAX, "/proc/%s", entry->d_name);

            // Get the process executable name.
            char exe_name[PATH_MAX];
            int len = readlink(strcat(proc_path, "/exe"), exe_name, PATH_MAX);
            if (len == -1) {
                continue;
            }
            exe_name[len] = '\0';

            // Check if the process executable is an executable file.
            if (access(exe_name, X_OK) != 0) {
                continue;
            }

            // Get the process memory map.
            char maps_path[PATH_MAX];
            snprintf(maps_path, PATH_MAX, "/proc/%s/maps", entry->d_name);

            // Open the process memory map file.
            FILE *maps_file = fopen(maps_path, "r");
            if (maps_file == NULL) {
                continue;
            }

            // Iterate over the process memory map file and collect the process data.
            char line[1024];
            while (fgets(line, 1024, maps_file) != NULL) {
                // Get the virtual address and size of the process data.
                char *addr_str = strtok(line, "-");
                char *size_str = strtok(NULL, " ");

                // Convert the virtual address and size to integers.
                unsigned long addr = strtoul(addr_str, NULL, 16);
                unsigned long size = strtoul(size_str, NULL, 16);

                // Calculate the virtual size.
                unsigned long virtual_size = size - addr;

                // Collect entropy data (you can replace this with your desired method).
                unsigned char entropy[16];
                for (int i = 0; i < sizeof(entropy); i++) {
                    entropy[i] = (unsigned char)(rand() % 256);
                }

                // Calculate entropy for the data.
                double entropy_value = calculate_entropy(entropy, sizeof(entropy));

                // Write the process data to the CSV file.
                fprintf(fp, "%lu,%lu,%f,%f\n", size, addr, entropy_value, (double)virtual_size);
            }

            // Close the process memory map file.
            fclose(maps_file);
        }
    }

    // Close the CSV file.
    fclose(fp);

    // Close the /proc directory.
    closedir(proc_dir);

    return 0;
}
